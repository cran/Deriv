% Generated by roxygen2 (4.0.2): do not edit by hand
\name{Deriv}
\alias{Deriv}
\alias{drule}
\alias{qlist}
\title{Symbollic differentiation of an expression or function}
\usage{
Deriv(f, x = if (is.function(f)) names(formals(f)) else all.vars(if
  (is.character(f)) parse(text = f) else f), env = if (is.function(f))
  environment(f) else parent.frame(), use.D = FALSE, cache.exp = TRUE)

qlist(...)
}
\arguments{
\item{f}{An expression or function to be differentiated.
f can be \itemize{
 \item a user defined function: \code{function(x) x**n}
 \item a string: \code{"x**n"}
 \item an expression: \code{expression(x**n)}
 \item a call: \code{call("^", quote(x), quote(n))}
 \item a language: \code{quote(x**n)}
 \item a right hand side of a formula: \code{~ x**n} or \code{y ~ x**n}
}}

\item{x}{An optiona character vector with variable name(s) with resptect to which
\code{f} must be differentiated. If not provided, x is guessed from
\code{names(formals(f))}, if \code{f} is a function, or from all variables in f
in other cases. If f is a primitive
function, x is set to \code{names(formals(args(f)))}}

\item{env}{An environment where the symbols and functions are searched for.
Defaults to \code{parent.frame()} for \code{f} expression and to
\code{environment(f)} if \code{f} is a function. For primitive function,
it is set by default to .GlobalEnv}

\item{use.D}{An optional logical (default FALSE), indicates if base::D()
must be used for differentiation of basic expressions.}

\item{cache.exp}{An optional logical (default TRUE), indicates if
final expression must be optimized with cached subexpressions.
If enabled, repeated calculations are made only once and their
results stored in cache variables which are then reused.}

\item{...}{(in \code{qlist()}) is a suite of named unevaluated expressions.
 It is used to add derivative rules to \code{drule} environment.}
}
\value{
\itemize{
 \item a function if \code{f} is a function
 \item an expression if \code{f} is an expression
 \item a character string if \code{f} is a character string
 \item a language (usually a so called 'call' but may be also a symbol or just a numeric) for other types of \code{f}
}
}
\description{
Symbollic differentiation of an expression or function
}
\details{
R already contains two differentiation functions: D and deriv. D does
simple univariate differentiation.  "deriv" uses D do to multivariate
differentiation.  The output of "D" is an expression, whereas the output of
"deriv" can be an executable function.

R's existing functions have several limitations.  They can probably be fixed,
but since they are written in C, this would probably require a lot of work.
Limitations include:
\itemize{
 \item The derivatives table can't be modified at runtime, and is only available
in C.
 \item Function cannot substitute function calls.  eg:
	f <- function(x, y) x + y; deriv(~f(x, x^2), "x")
}

So, here are the advantages of this implementation:

\itemize{
 \item It is entirely written in R, so would be easier to maintain.
 \item Can do multi-variate differentiation.
 \item Can differentiate function calls:
 \itemize{
	   \item if the function is in the derivative table, then the chain rule
	is applied.  For example, if you declared that the derivative of
	sin is cos, then it would figure out how to call cos correctly.
	   \item if the function is not in the derivative table (or it is anonymous),
	then the function body is substituted in.
	   \item these two methods can be mixed.  An entry in the derivative table
	need not be self-contained -- you don't need to provide an infinite
	chain of derivatives.
 }
 \item It's easy to add custom entries to the derivatives table, e.g.

  \code{drule[["cos"]] <- qlist(x=-sin(x))}

  The chain rule will be automatically applied if needed.
 \item The output is an executable function, which makes it suitable
     for use in optimization problems.
 \item Compound functions (i.e. piece-wise functions based on if-else operator) can
     be differentiated (cf. examples section).
}

Two working environments \code{drule} and \code{simplifications} are
exported in the package namescape.
As their names indicate, they contain tables of derivative and
simplification rules.
To see the list of defined rules do \code{ls(drule)}.
To add your own derivative rule for a function called say \code{sinpi(x)} calculating sin(pi*x), do \code{drule[["sinpi"]] <- qlist(x=pi*cospi(x))}.
Here, "x" stands for the first and unique argument in \code{sinpi()} definition. For a function that might have more than one argument,
e.g. \code{log(x, base=exp(1))}, the drule entry must be a list with a named rule
per argument. See \code{drule$log} for an example to follow.
After adding \code{sinpi} you can differentiate expressions like \code{Deriv(~ sinpi(x^2), "x")}. The chain rule will automatically apply.

NB. In \code{abs()} and \code{sign()} function, singularity treatment at point 0 is left to user's care.

NB2. In Bessel functions, derivatives are calculated only by the first argument,
     not by the \code{nu} argument which is supposed to be constant.
}
\examples{
\dontrun{f <- function(x) x^2}
\dontrun{Deriv(f)}
# function (x)
# 2 * x

\dontrun{f <- function(x, y) sin(x) * cos(y)}
\dontrun{Deriv(f)}
# function (x, y)
# c(x = cos(x) * cos(y), y = -(sin(x) * sin(y)))

\dontrun{f_ <- Deriv(f)}
\dontrun{f_(3, 4)}
#              x         y
# [1,] 0.6471023 0.1068000

\dontrun{Deriv(~ f(x, y^2), "y")}
# -(2 * (y * sin(x) * sin(y^2)))

\dontrun{Deriv(quote(f(x, y^2)), c("x", "y"), cache.exp=FALSE)}
# c(x = cos(x) * cos(y^2), y = -(2 * (y * sin(x) * sin(y^2))))

\dontrun{Deriv(expression(sin(x^2) * y), "x")}
# expression(2*(x*y*cos(x^2)))

Deriv("sin(x^2) * y", "x") # differentiate only by x
"2 * (x * y * cos(x^2))"

Deriv("sin(x^2) * y", cache.exp=FALSE) # differentiate by all variables (here by x and y)
"c(x = 2 * (x * y * cos(x^2)), y = sin(x^2))"

# Compound function example (here abs(x) smoothed near 0)
fc <- function(x, h=0.1) if (abs(x) < h) 0.5*h*(x/h)**2 else abs(x)-0.5*h
Deriv("fc(x)", "x", cache.exp=FALSE)
"if (abs(x) < h) x/h else sign(x)"

# Example of a first argument that cannot be evaluated in the current environment:
\dontrun{
  suppressWarnings(rm("xx", "yy"))
  Deriv(xx^2+yy^2)
}
# c(xx = 2 * xx, yy = 2 * yy)

# Automatic differentiation (AD), note itermediate variable \\code{d} assignment
\dontrun{Deriv(~{d <- ((x-m)/s)^2; exp(-0.5*d)}, "x")}
#{
#   d <- ((x - m)/s)^2
#   .d_x <- 2 * ((x - m)/s^2)
#   -(0.5 * (.d_x * exp(-(0.5 * d))))
#}

# Custom derivation rule
\dontrun{
  myfun <- function(x, y=TRUE) NULL # do something usefull
  dmyfun <- function(x, y=TRUE) NULL # myfun derivative by x.
  drule[["myfun"]] <- qlist(x=dmyfun(x, y), y=NULL) # y is just a logical
  Deriv(myfun(z^2, FALSE), "z")
  # 2 * (z * dmyfun(z^2, FALSE))
}
}
\author{
Andrew Clausen (original version) and Serguei Sokol (maintainer)
}
\concept{
symbollic differentiation
}

